/*
 * stm32f4xx_i2c_driver.c
 *
 *  Created on: Feb 17, 2025
 *      Author: 35596
 */
#include "stm32f4xx_i2c_driver.h"

static uint8_t I2C_checkFlags(I2C_RegDef_t *pvI2Cx,I2C_SR1_Flags_t flag);
static void I2C_GenerateStartCondition(I2C_RegDef_t *pvI2Cx);
static void I2C_ExecuteAddressphase(I2C_RegDef_t *pvI2Cx,uint8_t address,uint8_t write_read);
static void I2C_ClearADDRFlag(I2C_handle *pI2C_handle);
static void I2C_MasterHandleRXNEInterrupt(I2C_handle *pvI2C_handle);
static void I2C_MasterHandleTXEInterrupt(I2C_handle *pvI2C_handle);

static uint16_t AHB_PreScaler[8] = {2,4,8,16,64,128,256,512};
static uint16_t APB1_PreScaler[4] = {2,4,8,16};

void I2C_Init(I2C_handle *pvI2C_handle)
{
	uint32_t tempreg = 0;
	uint16_t ccr_value = 0;

	//enable the clock for i2c peripheral
	I2C_PeriClkCtrl(pvI2C_handle->pvI2Cx,ENABLE);

	//configure FREQ field of CR2
	tempreg = 0;
	tempreg |= RCC_GetPCLK1Value() / 1000000U;
	pvI2C_handle->pvI2Cx->I2C_CR2 = (tempreg & 0x3F);

	//program the device own address
	tempreg=0;
	tempreg |= (pvI2C_handle->I2C_Cfg.I2C_device_address << 1);
	tempreg |= (1<<14);//refer bit field 14 of OAR1 reg
	pvI2C_handle->pvI2Cx->I2C_OAR1 = tempreg;

 	//CCR calculations
	tempreg = 0;
	if(pvI2C_handle->I2C_Cfg.I2C_scl_speed <= I2C_SPEED_SM)
	{
		//standard mode
		ccr_value = RCC_GetPCLK1Value() / (2 * pvI2C_handle->I2C_Cfg.I2C_scl_speed);
		tempreg |= ( ccr_value & 0xFFF);
	}
	else
	{
		//fast mode
		tempreg |= (1<<15);
		tempreg |= (pvI2C_handle->I2C_Cfg.I2C_FM_mode_dutyCycle << 14);
		if(pvI2C_handle->I2C_Cfg.I2C_FM_mode_dutyCycle == I2C_FM_DUTY_2)
		{
			ccr_value = RCC_GetPCLK1Value() / (3 * pvI2C_handle->I2C_Cfg.I2C_scl_speed);
		}
		else
		{
			ccr_value = RCC_GetPCLK1Value() / (25 * pvI2C_handle->I2C_Cfg.I2C_scl_speed);
		}
		tempreg |= ( ccr_value & 0xFFF);
	}
	pvI2C_handle->pvI2Cx->I2C_CCR = tempreg;

	//TRISE calculation
	tempreg = 0;
	if(pvI2C_handle->I2C_Cfg.I2C_scl_speed <= I2C_SPEED_SM)
	{
		//standard mode
		tempreg = (RCC_GetPCLK1Value() / (1000000))+1;
	}
	else
	{
		//FAST mode
		tempreg = ((RCC_GetPCLK1Value()*300) / (1000000000))+1;
	}
	pvI2C_handle->pvI2Cx->I2C_TRISE = (tempreg & 0x3F);

	//peripheral enable
	pvI2C_handle->pvI2Cx->I2C_CR1 |= (1<<0);

	//ack control bit
	tempreg = 0;
	tempreg |= (pvI2C_handle->I2C_Cfg.I2C_AckControl << I2C_ACK_BIT);
	pvI2C_handle->pvI2Cx->I2C_CR1 |= tempreg;
}
void I2C_MasterSendData(I2C_handle *pvI2C_handle,uint8_t *pTxBuffer, uint16_t len,uint8_t address)
{
	//Generate start condition
	I2C_GenerateStartCondition(pvI2C_handle->pvI2Cx);

	//wait for SB flag to be set
	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,SB));

	//Read SR1 register to clear SB
	uint32_t dummyRead = pvI2C_handle->pvI2Cx->I2C_SR1;
	(void)dummyRead;

	// write address to the DR register
	//7-bit address and set write bit for master transmission
	I2C_ExecuteAddressphase(pvI2C_handle->pvI2Cx,address,0);

	//Reading I2C_SR2 after reading I2C_SR1 clears the ADDR flag, even if the ADDR flag was
	//set after reading I2C_SR1.
	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,ADDR));

	I2C_ClearADDRFlag(pvI2C_handle);

	//shift register and data register empty
	//write the data to data register
	while(len)
	{
		while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,TxE));
		pvI2C_handle->pvI2Cx->I2C_DR = *pTxBuffer;
		pTxBuffer++;
		len--;
	}

	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,TxE));
	//byte transmission finished
	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,BTF));
	//Give stop condition
	I2C_GenerateStopCondition(pvI2C_handle->pvI2Cx);
}
void I2C_MasterSendDataIT(I2C_handle *pvI2C_handle,uint8_t *pTxBuffer, uint16_t len,uint8_t address)
{
	//update I2C handle
	pvI2C_handle->Txbuffer = pTxBuffer;
	pvI2C_handle->length= len;
	pvI2C_handle->devAddrs = address;
	pvI2C_handle->RxTxState= I2C_BUSY_TX;

	//Enable interrupt buffer, interrupt event and interrupt error
	pvI2C_handle->pvI2Cx->I2C_CR2 = ((1<<I2C_ITBUFEN_BIT) | (1<<I2C_ITEVTEN_BIT) | (1<<I2C_ITERREN_BIT));

	//Generate start condition
	I2C_GenerateStartCondition(pvI2C_handle->pvI2Cx);

}
void I2C_MasterReceiveDataIT(I2C_handle *pvI2C_handle,uint8_t *pRxBuffer, uint16_t len,uint8_t address)
{
	//update I2C handle
	pvI2C_handle->Txbuffer = pRxBuffer;
	pvI2C_handle->length= len;
	pvI2C_handle->devAddrs = address;
	pvI2C_handle->RxTxState= I2C_BUSY_RX;

	//Enable interrupt buffer, interrupt event and interrupt error
	pvI2C_handle->pvI2Cx->I2C_CR2 = ((1<<I2C_ITBUFEN_BIT) | (1<<I2C_ITEVTEN_BIT) | (1<<I2C_ITERREN_BIT));

	//Generate start condition
	I2C_GenerateStartCondition(pvI2C_handle->pvI2Cx);

}
void I2C_EV_Handling(I2C_handle *pvI2C_handle)
{
	//Interrupt handling for both master and slave mode of a device

	uint32_t temp1=0,temp2=0,temp3=0;
	//1. Handle For interrupt generated by SB event
	//	Note : SB flag is only applicable in Master mode
	temp1 = (pvI2C_handle->pvI2Cx->I2C_CR2 & (1<< I2C_ITEVTEN_BIT ));
	temp2 = (pvI2C_handle->pvI2Cx->I2C_CR2 & (1<< I2C_ITBUFEN_BIT));

	//this also is read of SR1, which clears the SB
	temp3 = (pvI2C_handle->pvI2Cx->I2C_SR1 & (1<<SB));

	if(temp1 && temp3)
	{
		//SB is set
		//It is always zero for slave
		//execute address phase
		if(pvI2C_handle->RxTxState ==I2C_BUSY_TX)
		{
			I2C_ExecuteAddressphase(pvI2C_handle->pvI2Cx,pvI2C_handle->devAddrs,WRITE);
		}
		else if(pvI2C_handle->RxTxState ==I2C_BUSY_RX)
		{
			I2C_ExecuteAddressphase(pvI2C_handle->pvI2Cx,pvI2C_handle->devAddrs,READ);
		}
	}

	//2. Handle For interrupt generated by ADDR event
	//Note : When master mode : Address is sent
	//		 When Slave mode   : Address matched with own address
	temp3 = (pvI2C_handle->pvI2Cx->I2C_SR1 & (1<<ADDR));
	if(temp1 && temp3)
	{
		//ADDR is set
		I2C_ClearADDRFlag(pvI2C_handle);
	}

	temp3 =  (pvI2C_handle->pvI2Cx->I2C_SR1 & (1<<TxE));
	if(temp1 && temp2 && temp3)
	{
		//confirm that we are in master mode
		if(pvI2C_handle->pvI2Cx->I2C_SR2 & (1<< I2C_SR2_MSL))
		{
			//TxE is set
			//We have to do the data transmission
			if(pvI2C_handle->RxTxState == I2C_BUSY_TX)
			{
				I2C_MasterHandleTXEInterrupt(pvI2C_handle);
			}
		}
	}

	//3. Handle For interrupt generated by BTF(Byte Transfer Finished) event
	temp3 =  (pvI2C_handle->pvI2Cx->I2C_SR1 & (1<<BTF));
	if(temp1 && temp3)
	{
		if(pvI2C_handle->RxTxState == I2C_BUSY_TX)
		{
			//make sure that TxE is also set
			if(pvI2C_handle->pvI2Cx->I2C_SR1 & (1<<TxE))
			{
				//BTF, TxE =1
				if(pvI2C_handle->length==0)
				{
					//Generate STOP condition
					//Take the decision based on repeated start request
					if(pvI2C_handle->Sr != SET)
					{
						I2C_GenerateStopCondition(pvI2C_handle->pvI2Cx);
					}
					//reset all the members of handle structure
					I2C_CloseSendData(pvI2C_handle);

					//Noyify the application about transmission complete
					I2C_ApplicationEventCallback(pvI2C_handle,I2C_EV_TX_COMPLT);
				}
			}
		}
		else if(pvI2C_handle->RxTxState == I2C_BUSY_RX)
		{
			;
		}
	}
	//4. Handle For interrupt generated by STOPF event
	// Note : Stop detection flag is applicable only slave mode .
	//For master this flag will never be set
	temp3 =  (pvI2C_handle->pvI2Cx->I2C_SR1 & (1<<STOPF));
	if(temp1 && temp3)
	{
		//STOPF is set
		//clear the STOPF => read Sr1 and write to Cr1
		pvI2C_handle->pvI2Cx->I2C_CR1 |= 0x0000;//it is kind of dummy write which do not alter any other bit

		//Notify the application that STOP is detected
		I2C_ApplicationEventCallback(pvI2C_handle,I2C_EV_STOP_DETECTED);

	}

	//5. Handle For interrupt generated by TXE event
//	temp3 =  (pvI2C_handle->pvI2Cx->I2C_SR1 & (1<<TxE));
//	if(temp1 && temp2 && temp3)
//	{
//		//confirm that we are in master mode
//		if(pvI2C_handle->pvI2Cx->I2C_SR2 & (1<< I2C_SR2_MSL))
//		{
//			//TxE is set
//			//We have to do the data transmission
//			if(pvI2C_handle->RxTxState == I2C_BUSY_TX)
//			{
//				I2C_MasterHandleTXEInterrupt(pvI2C_handle);
//			}
//		}
//	}

	//6. Handle For interrupt generated by RXNE event
	temp3 =  (pvI2C_handle->pvI2Cx->I2C_SR1 & (1<<RxNE));
	if(temp1 && temp2 && temp3)
	{
		//check the device mode
		if(pvI2C_handle->pvI2Cx->I2C_SR2 & (1<< I2C_SR2_MSL))
		{
			//RxNE is set
			if(pvI2C_handle->RxTxState == I2C_BUSY_RX)
			{
				I2C_MasterHandleRXNEInterrupt(pvI2C_handle);
			}
		}
	}
}
void I2C_ER_Handling(I2C_handle *pI2CHandle)
{

	uint32_t temp1,temp2;

    //Know the status of  ITERREN control bit in the CR2
	temp2 = (pI2CHandle->pvI2Cx->I2C_CR2) & ( 1 << I2C_ITERREN_BIT);


/***********************Check for Bus error************************************/
	temp1 = (pI2CHandle->pvI2Cx->I2C_SR1) & ( 1<< BERR);
	if(temp1  && temp2 )
	{
		//This is Bus error

		//Implement the code to clear the buss error flag
		pI2CHandle->pvI2Cx->I2C_SR1 &= ~( 1 << BERR);

		//Implement the code to notify the application about the error
	   I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_BERR);
	}

/***********************Check for arbitration lost error************************************/
	temp1 = (pI2CHandle->pvI2Cx->I2C_SR1) & ( 1 << ARLO );
	if(temp1  && temp2)
	{
		//This is arbitration lost error

		//Implement the code to clear the arbitration lost error flag
		pI2CHandle->pvI2Cx->I2C_SR1 &= ~( 1 << ARLO);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,ARLO);
	}

/***********************Check for ACK failure  error************************************/

	temp1 = (pI2CHandle->pvI2Cx->I2C_SR1) & ( 1 << AF);
	if(temp1  && temp2)
	{
		//This is ACK failure error

	    //Implement the code to clear the ACK failure error flag
		pI2CHandle->pvI2Cx->I2C_SR1 &= ~( 1 << AF);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_ARLO);
	}

/***********************Check for Overrun/underrun error************************************/
	temp1 = (pI2CHandle->pvI2Cx->I2C_SR1) & ( 1 << OVR);
	if(temp1  && temp2)
	{
		//This is Overrun/underrun

	    //Implement the code to clear the Overrun/underrun error flag
		pI2CHandle->pvI2Cx->I2C_SR1 &= ~( 1 << OVR);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_OVR);
	}

/***********************Check for Time out error************************************/
	temp1 = (pI2CHandle->pvI2Cx->I2C_SR1) & ( 1 << TIMEOUT);
	if(temp1  && temp2)
	{
		//This is Time out error

	    //Implement the code to clear the Time out error flag
		pI2CHandle->pvI2Cx->I2C_SR1 &= ~( 1 << TIMEOUT);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_TIMEOUT);
	}

}
static void I2C_MasterHandleTXEInterrupt(I2C_handle *pvI2C_handle)
{

		if(pvI2C_handle->length>0)
		{
			//1. load the data in DR
			pvI2C_handle->pvI2Cx->I2C_DR = *(pvI2C_handle->Txbuffer);

			//2. Decrement the length
			pvI2C_handle->length--;

			//Increment the buffer address
			pvI2C_handle->Txbuffer++;
		}
}
static void I2C_MasterHandleRXNEInterrupt(I2C_handle *pvI2C_handle)
{
	//we have to perform the data reception
	if(pvI2C_handle->RxSize == 1)
	{
		*pvI2C_handle->Rxbuffer = pvI2C_handle->pvI2Cx->I2C_DR;
		pvI2C_handle->RxSize--;
	}

	if(pvI2C_handle->RxSize > 1)
	{
		if(pvI2C_handle->RxSize == 2)
		{
			//ack reset
			uint32_t tempreg = (~(pvI2C_handle->I2C_Cfg.I2C_AckControl) << I2C_ACK_BIT);
			pvI2C_handle->pvI2Cx->I2C_CR1 = tempreg;
		}

		//read DR
		*pvI2C_handle->Rxbuffer = pvI2C_handle->pvI2Cx->I2C_DR;
		pvI2C_handle->RxSize--;
		pvI2C_handle->Rxbuffer++;

	}
	if(pvI2C_handle->RxSize == 0)
	{
		//close the I2C data reception and notify the application

		//Generate tge STOP condition
		I2C_GenerateStopCondition(pvI2C_handle->pvI2Cx);

		//close the I2cx
		I2C_CloseReceiveData(pvI2C_handle);

		//Notify the application that STOP is detected
		I2C_ApplicationEventCallback(pvI2C_handle,I2C_EV_RX_COMPLT);
	}
}

void I2C_CloseReceiveData(I2C_handle *pvI2C_handle)
{
	//clear ITBUFEN bit
	pvI2C_handle->pvI2Cx->I2C_CR2 &= ~( 1<<I2C_ITBUFEN_BIT );

	//clear ITEVEN bit
	pvI2C_handle->pvI2Cx->I2C_CR2 &= ~( 1<<I2C_ITEVTEN_BIT );

	pvI2C_handle->Rxbuffer = '\0';
	pvI2C_handle->RxSize = 0;
	pvI2C_handle->length = 0;
	pvI2C_handle->RxTxState = I2C_READY;

	if(pvI2C_handle->I2C_Cfg.I2C_AckControl == I2C_ACK_ENABLE )
	{
		//set ACK back
		uint32_t tempreg = ((pvI2C_handle->I2C_Cfg.I2C_AckControl) << I2C_ACK_BIT);
		pvI2C_handle->pvI2Cx->I2C_CR1 = tempreg;
	}

}
void I2C_CloseSendData(I2C_handle *pvI2C_handle)
{
	//clear ITBUFEN bit
	pvI2C_handle->pvI2Cx->I2C_CR2 &= ~( 1<<I2C_ITBUFEN_BIT );

	//clear ITEVEN bit
	pvI2C_handle->pvI2Cx->I2C_CR2 &= ~( 1<<I2C_ITEVTEN_BIT );

	pvI2C_handle->Txbuffer = '\0';
	pvI2C_handle->length = 0;
	pvI2C_handle->RxTxState = I2C_READY;
}
void I2C_MasterReceiveData(I2C_handle *pvI2C_handle,uint8_t *pRxBuffer, uint16_t len,uint8_t address)
{
	//Generate start condition
	I2C_GenerateStartCondition(pvI2C_handle->pvI2Cx);

	//wait for SB flag to be set
	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,SB));

	//Read SR1 register to clear SB
	uint32_t dummyRead = pvI2C_handle->pvI2Cx->I2C_SR1;
	(void)dummyRead;

	// write address to the DR register
	//7-bit address and set read bit for master transmission
	I2C_ExecuteAddressphase(pvI2C_handle->pvI2Cx,address,0);

	//Reading I2C_SR2 after reading I2C_SR1 clears the ADDR flag, even if the ADDR flag was
	//set after reading I2C_SR1.
	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,ADDR));

	I2C_ClearADDRFlag(pvI2C_handle);

	//shift register and data register empty
	//write the data to data register
	//this is only added since testing on I2C FRAM MB85RC256V
	uint8_t memory_address_bytes = 2;
	while(memory_address_bytes)
	{
		while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,TxE));
		pvI2C_handle->pvI2Cx->I2C_DR = *pRxBuffer;
		pRxBuffer++;
		memory_address_bytes--;
	}
	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,TxE));

	len -= 2;

	//Generate  Repeated start condition
	I2C_GenerateStartCondition(pvI2C_handle->pvI2Cx);

	//wait for SB flag to be set
	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,SB));

	//Read SR1 register to clear SB
	dummyRead = pvI2C_handle->pvI2Cx->I2C_SR1;
	(void)dummyRead;

	// write address to the DR register
	//7-bit address and set read bit for master transmission
	I2C_ExecuteAddressphase(pvI2C_handle->pvI2Cx,address,1);

	//Reading I2C_SR2 after reading I2C_SR1 clears the ADDR flag, even if the ADDR flag was
	//set after reading I2C_SR1.
	while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,ADDR));

	if(len==1)
	{
		I2C_ClearADDRFlag(pvI2C_handle);

		while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,RxNE));
		*pRxBuffer = pvI2C_handle->pvI2Cx->I2C_DR;
		len--;

		//ack reset
		uint32_t tempreg = (~(pvI2C_handle->I2C_Cfg.I2C_AckControl) << I2C_ACK_BIT);
		pvI2C_handle->pvI2Cx->I2C_CR1 = tempreg;

		//Give stop condition
		I2C_GenerateStopCondition(pvI2C_handle->pvI2Cx);
	}
	else if(len>=2)
	{
		I2C_ClearADDRFlag(pvI2C_handle);
		//byte transmission finished
		while(len>=1)
		{
			//while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,BTF));
			while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,RxNE));
			if(len==1)
			{
				//ack reset
				uint32_t tempreg = (~(pvI2C_handle->I2C_Cfg.I2C_AckControl) << I2C_ACK_BIT);
				pvI2C_handle->pvI2Cx->I2C_CR1 = tempreg;

				//Give stop condition
				I2C_GenerateStopCondition(pvI2C_handle->pvI2Cx);
			}

			*pRxBuffer = pvI2C_handle->pvI2Cx->I2C_DR;
			pRxBuffer++;
			len--;
		}
//		*pRxBuffer = pvI2C_handle->pvI2Cx->I2C_DR;
//		pRxBuffer++;
//		len--;
	}
	/*else
	{
		I2C_ClearADDRFlag(pvI2C_handle);

		while(len>1)
		{

			while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,RxNE));

			if(len==2)
			{
				//ack reset
				uint32_t tempreg = (~(pvI2C_handle->I2C_Cfg.I2C_AckControl) << I2C_ACK_BIT);
				pvI2C_handle->pvI2Cx->I2C_CR1 = tempreg;

				//I2C_ClearADDRFlag(pvI2C_handle);

				//byte transmission finished
				//while(!I2C_checkFlags(pvI2C_handle->pvI2Cx,BTF));

				//Give stop condition
				I2C_GenerateStopCondition(pvI2C_handle->pvI2Cx);
			}

			*pRxBuffer = pvI2C_handle->pvI2Cx->I2C_DR;
			pRxBuffer++;

			len--;
		}
	}*/

	//set ACK back
	if(len == 0)
	{
		if(pvI2C_handle->I2C_Cfg.I2C_AckControl == I2C_ACK_ENABLE)
		{
			uint32_t tempreg = (pvI2C_handle->I2C_Cfg.I2C_AckControl) << I2C_ACK_BIT;
			pvI2C_handle->pvI2Cx->I2C_CR1 = tempreg;
		}
	}
}

static void I2C_GenerateStartCondition(I2C_RegDef_t *pvI2Cx)
{
	//Generate start condition
	pvI2Cx->I2C_CR1 |= (1 << I2C_START_BIT);

}
void I2C_GenerateStopCondition(I2C_RegDef_t *pvI2Cx)
{
	//Generate start condition
	pvI2Cx->I2C_CR1 |= (1 << I2C_STOP_BIT);

}
static void I2C_ExecuteAddressphase(I2C_RegDef_t *pvI2Cx,uint8_t address,uint8_t write_read)
{
	address = (address<<1);
	address |= ((write_read & 0x1)<<0);
	pvI2Cx->I2C_DR = address;
}

static void I2C_ClearADDRFlag(I2C_handle *pI2C_handle)
{
	uint32_t dummyRead = 0;
	//confirm the device mode
	if(pI2C_handle->pvI2Cx->I2C_SR2 & (1<<I2C_SR2_MSL))
	{
		if(pI2C_handle->RxTxState == I2C_BUSY_RX)
		{
			//first disable the ACK
			pI2C_handle->pvI2Cx->I2C_CR1 &= ~(1<<pI2C_handle->I2C_Cfg.I2C_AckControl);

			//clear the ADDR
			dummyRead = pI2C_handle->pvI2Cx->I2C_SR1;
			dummyRead = pI2C_handle->pvI2Cx->I2C_SR2;
			(void)dummyRead;
		}
		else
		{
			//clear the ADDR
			dummyRead = pI2C_handle->pvI2Cx->I2C_SR1;
			dummyRead = pI2C_handle->pvI2Cx->I2C_SR2;
			(void)dummyRead;
		}
	}
	else //in receiver mode
	{
		//clear the ADDR
		dummyRead = pI2C_handle->pvI2Cx->I2C_SR1;
		dummyRead = pI2C_handle->pvI2Cx->I2C_SR2;
		(void)dummyRead;
	}
}
static uint8_t I2C_checkFlags(I2C_RegDef_t *pvI2Cx,I2C_SR1_Flags_t flag)
{
	if (pvI2Cx->I2C_SR1 & (1<<flag))
	{
		return SET;
	}
	else
	{
		return RESET;
	}
}
void I2C_PeriClkCtrl(I2C_RegDef_t *pvI2Cx,uint8_t EnDis)
{
	if(EnDis == ENABLE)
	{
		if( pvI2Cx == I2C1 )
		{
			I2C1_PCLK_EN();
		}
		else if( pvI2Cx == I2C2 )
		{
			I2C2_PCLK_EN();
		}
		else if( pvI2Cx == I2C3 )
		{
			I2C3_PCLK_EN();
		}
	}
	else
	{
		if( pvI2Cx == I2C1 )
		{
			I2C1_PCLK_DI();
		}
		else if( pvI2Cx == I2C2 )
		{
			I2C2_PCLK_DI();
		}
		else if( pvI2Cx == I2C3 )
		{
			I2C3_PCLK_DI();
		}
	}
}
/*
 * Refer https://www.st.com/resource/en/user_manual/um1724-stm32-nucleo64-boards-mb1136-stmicroelectronics.pdf
 * MCO from ST-LINK: MCO output of ST-LINK MCU is used as an input clock. This
 * frequency cannot be changed, it is fixed at 8 MHz and connected to
 * PF0/PD0/PH0-OSC_IN of the STM32 microcontroller.
 * The following configuration is needed:
 * – SB55 OFF and SB54 ON
 * – SB16 and SB50 ON
 * – R35 and R37 removed
 *
 * This function calculates the APB1 clock connected to I2C peripheral
 */

uint32_t RCC_GetPCLK1Value(void)
{
	uint32_t pclk1=0,SystemClk=0;
	uint8_t clksrc=0,temp = 0;
	uint16_t ahbp = 0, apb1 = 0;

	//read system clock source
	clksrc = ((RCC->CFGR >> 2) & 0x3);
	if(clksrc == 0)
	{
		SystemClk = 16000000; //source is HSI
	}
	else if(clksrc == 1)
	{
		SystemClk = 8000000; //source is HSE
	}
	else if(clksrc == 2)
	{
		SystemClk = RCC_GetPLLOutput();// source is PLL
	}
	//read ahbp pre-scaler value
	temp = ((RCC->CFGR >> 4) & 0xF);
	if(temp<8)
	{
		ahbp = 1;
	}
	else
	{
		ahbp = AHB_PreScaler[temp-8];
	}

	//read apb1 pre-scaler value
	temp = ((RCC->CFGR >> 10) & 0x7);
	if(temp<4)
	{
		apb1 = 1;
	}
	else
	{
		apb1 = APB1_PreScaler[temp-4];
	}

	pclk1 = ((SystemClk/ahbp)/apb1);
	return pclk1;
}
/*
 * Not implemented
 */
uint32_t RCC_GetPLLOutput()
{
	return 0;
}

void I2C_IRQInterruptConfig(uint8_t IRQNumber,uint8_t EnDis)
{
	 if(EnDis)
	 {
		 if(IRQNumber < 32)
		 {
			 *NVIC_ISER0 |= (1<<IRQNumber);
		 }
		 else if(IRQNumber >= 32 && IRQNumber < 64)
		 {
			 *NVIC_ISER1 |= (1<<(IRQNumber % 32));
		 }
		 else if(IRQNumber >=64 && IRQNumber < 96)
		 {
			 *NVIC_ISER2 |= (1<<(IRQNumber % 64));
		 }
		 else if(IRQNumber >=96 && IRQNumber < 128)
		 {
			 *NVIC_ISER3 |= (1<<(IRQNumber % 96));
		 }
	 }
	 else
	 {
		 if(IRQNumber < 32)
		 {
			 *NVIC_ICER0 |= (1<<IRQNumber);
		 }
		 else if(IRQNumber >= 32 && IRQNumber < 64)
		 {
			 *NVIC_ICER1 |= (1<<(IRQNumber % 32));
		 }
		 else if(IRQNumber >=64 && IRQNumber < 96)
		 {
			 *NVIC_ICER2 |= (1<<(IRQNumber % 64));
		 }
		 else if(IRQNumber >=96 && IRQNumber < 128)
		 {
			 *NVIC_ICER3 |= (1<<(IRQNumber % 96));
		 }
	 }
}
void I2C_IRQPriorityConfig(uint8_t IRQPriority)
{
	 uint8_t pri_reg_number=0;
	 uint8_t pri_reg_section =0;
	 uint8_t shift_amount = 0;
	 pri_reg_number = IRQPriority / 4;
	 pri_reg_section = IRQPriority % 4;
	 shift_amount = (8 * pri_reg_section)+ (8-CM4_INT_PRI_BIT_IMPLEMENTATION);
	 *(NVIC_PRIO_BASEADDRS + (4 *pri_reg_number)) |= (IRQPriority << shift_amount );
}
