/*
 * stm32f4xx_spi_driver.c
 *
 *  Created on: Apr 2, 2025
 *      Author: 35596
 */

#include "stm32f4xx_spi_driver.h"


void SPI_Init(SPI_Handle_t *pvSPI_handle)
{
	//first let configure the SPI_CR1 register

	uint32_t tempreg =0;

	//set device mode, master/slave
	tempreg |= ( pvSPI_handle->SPIConfig.SPI_DeviceMode << SPI_CR1_MSTR );

	//set communication modes
	if(pvSPI_handle->SPIConfig.SPI_BusConfig == SPI_FULL_DUPLEX)
	{
		//BIDI mode is cleared
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
	}
	else if(pvSPI_handle->SPIConfig.SPI_BusConfig == SPI_HALF_DUPLEX)
	{
		//BIDI mode is Set
		tempreg |= (1 << SPI_CR1_BIDIMODE);
	}
	else//simplex
	{
		//BIDI mode is cleared
		//RXONLY is set
		//In simplex Readonly is provided
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
		tempreg |= (1 << SPI_CR1_RXONLY);
	}

	//set clock speed
	tempreg |= ( pvSPI_handle->SPIConfig.SPI_SclkSpeed <<  );

	//set data format
	if(pvSPI_handle->SPIConfig.SPI_DFF == SPI_DFF_8BIT)
	{
		tempreg &= ~( 1<<11 );
	}
	else if(pvSPI_handle->SPIConfig.SPI_DFF == SPI_DFF_16BIT)
	{
		tempreg |= ( 1<<11 );
	}

	//set clock polarity
	if(pvSPI_handle->SPIConfig.SPI_CPOL == SPI_CPOL_HIGH)
	{
		tempreg |= ( 1<<1 );
	}
	else
	{
		tempreg &= ~( 1<<1 );
	}

	//set clock phase
	if(pvSPI_handle->SPIConfig.SPI_CPOL == SPI_CPHA_HIGH)
	{
		tempreg |= ( 1<<0 );
	}
	else
	{
		tempreg &= ~( 1<<0 );
	}

	//set software slave select
	if( pvSPI_handle->SPIConfig.SPI_SSM == SPI_SSM_ENABLE )
	{
		tempreg |= ( 1<<9 );
	}
	else
	{
		tempreg &= ~( 1<<9 );
	}
}

void SPI_PeriClkCtrl(SPI_RegDef_t * pvSPIx,uint8_t EnDis)
{
	if(EnDis == ENABLE)
	{
		if( pvSPIx == SPI1 )
		{
			SPI1_PCLK_EN();
		}
		else if( pvSPIx == SPI2 )
		{
			SPI2_PCLK_EN();
		}
		else if( pvSPIx == SPI3 )
		{
			SPI3_PCLK_EN();
		}
	}
	else
	{
		if( pvSPIx == SPI1 )
		{
			SPI1_PCLK_DI();
		}
		else if( pvSPIx == SPI2 )
		{
			SPI2_PCLK_DI();
		}
		else if( pvSPIx == SPI3 )
		{
			SPI3_PCLK_DI();
		}
	}
}
