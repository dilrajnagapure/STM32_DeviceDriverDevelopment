/*
 * stm32f4xx_spi_driver.c
 *
 *  Created on: Apr 2, 2025
 *      Author: 35596
 */

#include "stm32f4xx_spi_driver.h"


void SPI_Init(SPI_Handle_t *pvSPI_handle)
{
	//first let configure the SPI_CR1 register

	uint32_t tempreg =0;

	//Enable SPI peripheral clock
	SPI_PeriClkCtrl(pvSPI_handle->pSPIx,ENABLE);

	//set device mode, master/slave
	tempreg |= ( pvSPI_handle->SPIConfig.SPI_DeviceMode << SPI_CR1_MSTR );

	//set communication modes
	if(pvSPI_handle->SPIConfig.SPI_BusConfig == SPI_FULL_DUPLEX)
	{
		//BIDI mode is cleared
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
	}
	else if(pvSPI_handle->SPIConfig.SPI_BusConfig == SPI_HALF_DUPLEX)
	{
		//BIDI mode is Set
		tempreg |= (1 << SPI_CR1_BIDIMODE);
	}
	else//simplex
	{
		//BIDI mode is cleared
		//RXONLY is set
		//In simplex Readonly is provided
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
		tempreg |= (1 << SPI_CR1_RXONLY);
	}

	//set clock speed
	tempreg |= ( pvSPI_handle->SPIConfig.SPI_SclkSpeed << SPI_CR1_BR );

	//set data format
	tempreg |= ( pvSPI_handle->SPIConfig.SPI_DFF << SPI_CR1_DFF );

	//set clock polarity
	tempreg |= ( pvSPI_handle->SPIConfig.SPI_CPOL << SPI_CR1_CPOL );

	//set clock phase
	tempreg |= ( pvSPI_handle->SPIConfig.SPI_CPHA << SPI_CR1_CPHA );

	//set software slave select
	tempreg |= ( pvSPI_handle->SPIConfig.SPI_SSM << SPI_CR1_SSM );

	//SSI enable/disable when SSM is enabled
	if( pvSPI_handle->SPIConfig.SPI_SSM == SET )
		tempreg |= ( pvSPI_handle->SPIConfig.SPI_SSI << SPI_CR1_SSI );

	//enable SPI peripheral
	tempreg |= ( 1<< SPI_CR1_SPE);

	pvSPI_handle->pSPIx->SPI_CR1 = tempreg;
}

void SPI_MasterSendData(SPI_RegDef_t *pvSPIx, uint8_t *pTxBuffer, uint32_t Len)
{

	while( Len )
	{
		//wait for TxE = 1
		while(!(pvSPIx->SPI_SR & ( 1 << SPI_SR_TXE )));

		//check the DFF in CR1 to send 8 or 16 bit data
		if( pvSPIx->SPI_CR1 & ( 1 << SPI_CR1_DFF) )
		{
			//DFF is 16 bit
			pvSPIx->SPI_DR = *((uint16_t*)pTxBuffer);
			Len--;
			Len--;
			(uint16_t*)pTxBuffer++;
		}
		else
		{
			//DFF is 8 bit
			pvSPIx->SPI_DR = *pTxBuffer;
			pTxBuffer++;
			Len--;
		}
	}
	//confirm last data byte sent by checking TxE = 1, BSY = 0
	while(!(pvSPIx->SPI_SR & ( 1 << SPI_SR_TXE )));
	while((pvSPIx->SPI_SR & ( 1 << SPI_SR_BSY )));
}

void SPI_MasterReceiveData(SPI_RegDef_t *pvSPIx, uint8_t *pTxBuffer, uint32_t Len)
{

	while( Len )
	{
		//wait for TxE = 1
		while(!(pvSPIx->SPI_SR & ( 1 << SPI_SR_RXNE )));

		//read data from Data Register
		//check the DFF in CR1 to send 8 or 16 bit data
		if( pvSPIx->SPI_CR1 & ( 1 << SPI_CR1_DFF) )
		{
			//DFF is 16 bit
			*((uint16_t*)pTxBuffer) = pvSPIx->SPI_DR;
			Len--;
			Len--;
			(uint16_t*)pTxBuffer++;
		}
		else
		{
			//DFF is 8 bit
			*pTxBuffer = pvSPIx->SPI_DR;
			pTxBuffer++;
			Len--;
		}
	}
	//confirm last data byte sent by checking TxE = 1, BSY = 0
	while(!(pvSPIx->SPI_SR & ( 1 << SPI_SR_TXE )));
	while((pvSPIx->SPI_SR & ( 1 << SPI_SR_BSY )));
}
void SPI_Close(SPI_RegDef_t *pvSPIx)
{
	pvSPIx->SPI_CR1 &= ~( 1 << SPI_CR1_SPE );
}
void SPI_PeriClkCtrl(SPI_RegDef_t * pvSPIx,uint8_t EnDis)
{
	if(EnDis == ENABLE)
	{
		if( pvSPIx == SPI1 )
		{
			SPI1_PCLK_EN();
		}
		else if( pvSPIx == SPI2 )
		{
			SPI2_PCLK_EN();
		}
		else if( pvSPIx == SPI3 )
		{
			SPI3_PCLK_EN();
		}
	}
	else
	{
		if( pvSPIx == SPI1 )
		{
			SPI1_PCLK_DI();
		}
		else if( pvSPIx == SPI2 )
		{
			SPI2_PCLK_DI();
		}
		else if( pvSPIx == SPI3 )
		{
			SPI3_PCLK_DI();
		}
	}
}

void SPI_IgnoreNSSPin(SPI_RegDef_t *pvSPIx,uint8_t EnDis)
{
	if( EnDis == SET )
	{
		pvSPIx->SPI_CR1 |= ( 1 << SPI_CR1_SSI );
	}
	else
	{
		pvSPIx->SPI_CR1 &= ~( 1 << SPI_CR1_SSI );
	}
}
