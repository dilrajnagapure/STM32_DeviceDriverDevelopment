/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include "stm32f4xx.h"
#include "stm32f4xx_gpio_driver.h"
#include "stm32f4xx_i2c_driver.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
extern void initialise_monitor_handles(void);
uint8_t toggle = 0;
void button_interrupt_program();
void led_blinking();
void button_read_polling();
void i2c_write_read_polling(void);
void i2c_write_read_interrupt(void);
int main(void)
{
	//initialise_monitor_handles();
	//printf("Hello Dilraj\n");

	i2c_write_read_interrupt();

	led_blinking();

	while(1)
	{;
	}
}

I2C_handle i2c1;
uint8_t Txbuffer[]={0x0,0x0,'A','B','C'},Rxbuffer[]={0x0,0x0,0,0,0,0};
void i2c_write_read_interrupt(void)
{
	GPIO_Handle_t I2CPins;
	I2CPins.pvGPIOx = GPIOB;
	I2CPins.GPIO_PinConfg.pinMode = GPIO_ALT_FUNC;
	I2CPins.GPIO_PinConfg.pinOPType = GPIO_OPENDRAIN;
	I2CPins.GPIO_PinConfg.pinPuPd = GPIO_NO_PUPD;//GPIO_PULL_UP;GPIO_NO_PUPD
	I2CPins.GPIO_PinConfg.pinSpeed = GPIO_MEDIUM_SPEED;//GPIO_HIGH_SPEED;
	I2CPins.GPIO_PinConfg.pinAltFunMode = AF4_I2C_1_to_3;

	GPIO_PeriClkCtrl(GPIOB,ENABLE);
	//scl
	I2CPins.GPIO_PinConfg.pinNumber = PIN_NUMBER_8;//SCL pin
	GPIO_Init(&I2CPins);

	//sda
	I2CPins.GPIO_PinConfg.pinNumber = PIN_NUMBER_9;//SDA pin
	GPIO_Init(&I2CPins);

	//initialize I2C configuration
	i2c1.pvI2Cx = I2C1;
	i2c1.I2C_Cfg.I2C_FM_mode_dutyCycle = I2C_FM_DUTY_2;
	i2c1.I2C_Cfg.I2C_scl_speed = I2C_SPEED_SM;
	i2c1.I2C_Cfg.I2C_device_address = 0x61;
	i2c1.I2C_Cfg.I2C_AckControl = I2C_ACK_ENABLE;
	i2c1.Sr = RESET;

	I2C_Init(&i2c1);

	// Enable IRQ configuration
	I2C_IRQInterruptConfig(IRQ_NO_I2C1_EV, SET);
	I2C_IRQInterruptConfig(IRQ_NO_I2C1_ER, SET);

	I2C_MasterSendDataIT(&i2c1, Txbuffer, 2, 0x50);
	for(uint32_t i=0;i<1000;i++);
	I2C_MasterReceiveDataIT(&i2c1, Rxbuffer, 4, 0x50);
}
void led_blinking()
{
	GPIO_Handle_t led;
	led.pvGPIOx = GPIOA;
	led.GPIO_PinConfg.pinMode = GPIO_OUTPUT;
	led.GPIO_PinConfg.pinOPType = GPIO_PUSHPULL;
	led.GPIO_PinConfg.pinPuPd = GPIO_NO_PUPD;
	led.GPIO_PinConfg.pinSpeed = GPIO_HIGH_SPEED;
	led.GPIO_PinConfg.pinAltFunMode = 0;
	led.GPIO_PinConfg.pinNumber = PIN_NUMBER_5;

	GPIO_PeriClkCtrl(GPIOA,ENABLE);
	GPIO_Init(&led);

	while(1)
	{
		GPIO_PinWrite(led.pvGPIOx,PIN_NUMBER_5,ENABLE);
		for(uint32_t i=0;i<100000;i++);

		GPIO_PinWrite(led.pvGPIOx,PIN_NUMBER_5,DISABLE);
		for(uint32_t i=0;i<100000;i++);

	}
}
void I2C1_EV_IRQHandler(void)
{
	I2C_EV_Handling(&i2c1);
}
void I2C1_ER_IRQHandler(void)
{
	I2C_ER_Handling(&i2c1);
}
void I2C_ApplicationEventCallback(I2C_handle *pvI2C_handle,uint8_t event)
{
	if(event == I2C_EV_TX_COMPLT)
	{
		//printf("Tx is completed\n");
	}
	else if(event == I2C_EV_RX_COMPLT)
	{
		//printf("Rx is completed\n");
	}
	else if(event == I2C_ERROR_AF)
	{
		//printf("ACK is failed\n");

		I2C_CloseSendData(pvI2C_handle);

		I2C_GenerateStopCondition(pvI2C_handle->pvI2Cx);

	}
}
